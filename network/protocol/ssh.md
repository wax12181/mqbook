# SSH协议体系结构(RFC4251)

## 摘要

Secure Shell（SSH）协议是用于安全远程登录的协议和不安全网络上的其他安全网络服务。本文描述了SSH协议的体系结构，以及SSH协议文档中使用的符号和术语。它也讨论了允许本地扩展的SSH算法命名系统。SSH协议由三个主要组件组成：1、传输层协议提供服务器认证，保密性和完全保密的完整性；2、用户身份验证协议将客户端验证到服务器；3、连接协议将加密隧道多路复用逻辑channel。这些协议的细节描述于单独的文件。

1. 简介

    Secure Shell（SSH）是一种用于安全远程登录和其他基于不安全网络上的安全服务的协议。它包括三大部分：
    *  传输层协议 [SSH-TRANS] 提供服务器身份认证，保密性和完整性。它可以选择性地支持压缩。传输层通常是运行在TCP/IP连接上，但也可以在其他可靠的数据流上。
    *  用户身份认证协议[SSH-USERAUTH] 进行客户端用户到服务器的身份认证。运行在传输层上。
    *  连接协议[SSH-CONNECT] 复用加密隧道进入多个逻辑channel。运行在用户认证协议上。

    一旦建立了安全传输层连接，客户端就发送服务请求。在用户认证完成后发送第二服务请求。允许新协议被定义并与上面列出的协议共存。

    连接协议提供了可用于很多种目的的channel。提供标准方法进行设置安全的交互式shell会话和转发（"隧道贯穿的"）任意TCP / IP端口和X11连接。

2. 贡献者

3. 本文档中使用的约定

    与SSH协议相关的所有文档都应使用关键字"MUST"，"MUST NOT"，"REQUIRED"，"SHALL"，"SHALL NOT"，"SHOULD"，"SHOULD NOT"，"RECOMMENDED"，"MAY"和"OPTIONAL"来描述需求。这些关键字的解释请参考[RFC2119]。

    当用于描述名称空间分配时，本文档中出现的关键词"PRIVATE USE"，"HIERARCHICAL ALLOCATION"， "FIRST COME FIRST SERVED"，"EXPERT REVIEW"，"SPECIFICATION REQUIRED", "IESG APPROVAL", "IETF CONSENSUS", and "STANDARDS ACTION" 的解释如[RFC2434]中所述。

    协议字段和填充它们的可能值在这组文档中被定义。协议字段将在消息定义中定义。作为一个例子，SSH_MSG_CHANNEL_DATA定义如下：

        byte      SSH_MSG_CHANNEL_DATA
        uint32    recipient channel
        string    data

    在这些文档中，当引用字段时，它们将出现在单引号中。当引用这些字段的值时，它们将出现在双引号内。使用上面的例子，'data'的可能值是"foo"和"bar"。

4. 体系结构

    1. 主机密钥（Host Keys）

        每个服务器主机应该有一个主机密钥。主机可能有使用多种不同的算法生成的多个主机密钥。多个主机可以共享相同的主机密钥。如果主机有密钥，它必须至少有一个使用各个所需公钥算法生成的密钥（DSS[FIPS-186-2]）。

        密钥交换（key exchange）期间使用服务器主机密钥来验证客户端正在与正确的服务器通信。为此，客户必须知道服务器的公共主机密钥。

        可以使用两种不同的信任模型：
        * 客户端有一个本地数据库，该数据库将每个主机名（由用户键入）与相应的公共主机密钥相关联。这种方法不需要中央管理基础设施，也不需要第三方协调。缺点是名称到密钥关联的数据库可能会成为维护的负担。
        * 主机名到密钥关联由可信认证机构(CA)进行认证。客户端仅知道CA根密钥，并且可以验证所有接受CA认证的主机密钥的有效性。

        第二种选择可以减轻维护问题，因为理想情况下只需要将一个CA密钥安全地存储在客户端上。另一方面，在授权之前，每个主机密钥必须得到中央权威机构的适当认证。同时，中央基础设施也有很多信任。

        该协议提供了这样的选项，即在第一次连接到主机时不检查服务器名称-主机密钥关联。这样就可以在没有事先通信主机密钥或证书的情况下进行通信。该连接仍然提供了防止被动监听的保护；然而，它变得容易被中间人攻击。默认情况下实现通常不应允许这样的连接，因为它们会构成潜在的安全性问题。但是，由于在撰写本文时没有广泛部署的关键基础设施，因此，在出现这样的基础设施之前，此选项使得协议在转换期间更加可用，同时仍然比旧解决方案提供了更高安全级别的安全性（例如，telnet[RFC0854]和rlogin [RFC1282]）。

        实现应该尽可能地检查主机密钥。一种可能的策略的示例是只接受主机密钥，而不检查第一次连接主机的情况，将密钥保存在本地数据库中，并在与该主机的所有未来连接中与该密钥进行比较。

        实现可以提供用于验证主机密钥的正确性的其他方法，例如，从公钥的SHA-1哈希[FIP-180-2]派生的十六进制指纹。这样可以使用电话或其他外部通信channel轻松验证指纹。

        所有实现都应提供不接受无法验证的主机密钥的选项。

        该工作组的成员认为'ease of use'对于最终用户接受安全解决方案至关重要，并且如果不使用新的解决方案，则安全性不会得到改善。因此，提供不检查服务器主机密钥的选项被认为可以提高因特网的整体安全性，即使它在允许的配置中降低了协议的安全性。

    2.  可扩展性（Extensibility）

        我们相信该协议会随着时间而发展，并且一些组织会希望使用他们自己的加密、身份验证和/或密钥交换方法。所有扩展的中央注册是繁琐的，特别是对于实验或分类特征。另一方面，没有中央注册会导致方法标识符中的冲突，使得互操作性变得困难。
    
        我们已经选择了具有特定格式的文本名称的算法、方法、格式和扩展协议。DNS名称用于创建本地名称空间，其中可以定义实验性或分类的扩展，而不必担心与其他实现冲突。
    
        一个设计目标是保持基础协议尽可能简单，并要求尽可能少的算法。然而，所有实现必须支持一组最小的算法以确保互操作性（这并不意味着所有主机上的本地策略都必须允许这些算法）。在相关协议文档中规定了强制需要实现的算法。

        附加的算法、方法、格式和扩展协议可以在单独的文档中定义。有关更多信息，请参见第6节，算法命名。

    3. 策略问题

        该协议允许加密、完整性、密钥交换、压缩和公钥算法和格式的完全协商。公共密钥加密，完整性，和压缩算法，可以因为不同方向而不同。
        
        在每个实现的配置机制中应解决以下策略问题：
        * 加密，完整性和压缩算法，分别对应不同方向。策略必须指定哪个是首选算法（例如，在每个类别中列出的第一种算法）。
        * 公钥算法和密钥交换方法可用于主机认证。不同公钥算法的可信主机密钥的存在也影响了这种选择。
        * 服务器对每个用户所需的身份验证方法。服务器的策略可能需要对某些或所有用户进行多个身份验证。所需的算法可能取决于用户试图获得访问的位置。
        * 允许用户使用连接协议执行的操作。一些问题与安全性有关：例如，策略不应该允许服务器在客户机上启动会话或运行命令，并且除非转发已经请求到的连接，否则禁止连接到身份认证代理。其他问题，如TCP/IP端口是否应该转发和应该由谁去转发，显然是本地策略的问题。这些问题中的许多可能涉及贯穿或绕过防火墙，也与本地安全策略相关。
    
    4. 安全属性

        SSH协议的主要目标是提高因特网上的安全性。它试图以一种易于部署的方式做到这一点，甚至以绝对安全为代价。
        * 所有使用的加密、完整性和公钥算法都是众所周知的、行之有效的算法
        * 所有算法都与密码学上健全的密钥大小一起使用，据信这些密钥大小提供保护，防止几十年来最强大的密码分析攻击。
        * 所有算法都经过协商，并且在某些算法被破坏的情况下，很容易在不修改基本协议的情况下切换到其他算法。

        作出具体让步，使广泛，快速部署更容易。出现这种情况的特定情况是验证服务器主机密钥确实属于期望的主机；协议允许省略验证，但这不是推荐的。据信，这在短期内显著提高了可用性，直到出现广泛的因特网公钥基础设施。

    5. 本地化和字符集支持

        在大多数情况下，SSH协议不直接传递将显示给用户的文本。然而，有些地方可能会传递这样的数据。当适用时，必须明确指定数据的字符集。在大多数地方，使用ISO-10646 UTF-8编码[RFC3629]。当适用时，还为语言标签[FRC3066]提供字段。

        一个大问题是交互式会话的字符集。没有明确的解决方案，因为不同的应用程序可以以不同的格式显示数据。客户端还可以使用不同类型的终端模拟器，并且终端模拟器有效地确定要使用的字符集。因此，没有提供直接指定终端会话数据的字符集或编码的位置。然而，终端模拟类型（例如，“vt100”）被发送到远程站点，并且隐式地指定字符集和编码。应用程序通常使用终端类型来确定它们使用什么字符集，或者使用一些外部手段确定字符集。终端模拟器还可以允许配置默认字符集。在任何情况下，终端会话的字符集主要被视为客户端本地问题。

        用于识别算法或协议的内部名称通常不显示给用户，并且必须在U-ASCII中。

        客户机和服务器用户名天然会受到服务器期望可接受的限制。然而，它们偶尔也会显示在日志、报告等中。它们必须使用ISO 10646 UTF-8编码，但在某些情况下可能需要其他编码。决定如何将用户名映射到可接受的用户名取决于服务器。推荐直接逐位，二进制比较。
        
        为了本地化的目的，协议试图最小化发送的文本消息的数量。当存在时，这样的消息通常涉及错误、调试信息或一些外部配置的数据。对于通常需要显示的数据，应该可以通过使用数字代码来获取本地化消息而不是发送消息。其余的消息应该是可配置的。

5. SSH协议中使用的数据类型表示
   
    ### byte

    一字节表示任意8位值（八位字节）。固定长度的数据有时表示为字节数组，写入字节[n]，其中n是数组中的字节数。

    ### boolean

    布尔值被存储为一个字节。值0表示假，值1表示真。所有非零值必须被解释为真；然而，应用程序不能存储除0和1以外的值

    ### uint32

    表示32位无符号整数。存储为四字节的顺序递减含义（网络字节顺序）。例如：值699921578（0x29 b7f4aa）被存储为29 b7 f4 aa。

    ### uint64

    表示64位无符号整数。存储为八字节的顺序递减含义（网络字节顺序）。

    ### string

    任意长度二进制字符串。允许字符串包含任意二进制数据，包括null字符和8位字符。它们以uint32的形式存储，其中包含它的长度（后面的字节数）和零（=空字符串）或者作为字符串值的更多字节。不使用终止null字符。

    字符串也用于存储文本。在这种情况下，U-ASCII用于内部名称，而ISO-10646 UTF-8可用于显示给用户的文本。终止空字符不应该正常存储在字符串中。例如：U-ASCII字符串“testing”被表示为“00 00 00 07 t e s t i n g”。UTF-8映射不会改变U-ASCII字符的编码。

    ### mpint

    表示两个补码格式的多精度整数，以字符串形式存储，每字节8位，MSB优先。负数的值为数据分区第一字节的最高有效位。如果最高有效位将被设置为正数，则该数字必须先于零字节。不包含值0或255的不必要的引导字节。值零必须存储为具有零字节数据的字符串。

    按照惯例，在Zyn中使用的模运算中所用的数字应该表示在0≤x＜n的范围内。

    举例:

        value (hex)        representation (hex)
        -----------        --------------------
        0                  00 00 00 00
        9a378f9b2e332a7    00 00 00 08 09 a3 78 f9 b2 e3 32 a7
        80                 00 00 00 02 00 80
        -1234              00 00 00 02 ed cc
        -deadbeef          00 00 00 05 ff 21 52 41 11

    ### name-list

    包含逗号分隔的名称列表的字符串。名称列表表示为包含其长度（字节数）的UIT32。接下来是一个逗号分隔的零个或多个名字的列表。一个名称必须有非零的长度，而且它不能包含“,”。由于这是一个名称列表，所包含的所有元素都是名称，而且必须是US-ASCII。上下文可能会对名称施加额外限制。例如，名称列表中的名称可能必须是有效算法标识符列表（请参阅下面的第6节）或[RFC3066]语言标记列表。名称列表中名称的顺序可能重要也可能不重要。同样，这取决于使用列表的上下文。绝不能使用终止空字符，既不能用于单个名称，也不能用于整个列表。

    举例:

       value                      representation (hex)
       -----                      --------------------
       (), the empty name-list    00 00 00 00
       ("zlib")                   00 00 00 04 7a 6c 69 62
       ("zlib,none")              00 00 00 09 7a 6c 69 62 2c 6e 6f 6e 65

6. 算法和方法命名

    SSH协议指的是特定的哈希、加密、完整性、压缩和按名称的密钥交换算法或方法。有一些标准的算法和方法，所有的实现都必须支持。也有在协议规范中定义的算法和方法，但它们是可选的。此外，预计一些组织将希望使用自己的算法或方法。

    在该协议中，所有算法和方法标识符必须是可打印的US-ASCII，非空字符串不超过64个字符。名称必须区分大小写。
    
    算法和方法名称有两种格式：
    * 不包含符号（@）的名称，与IETF保持一致。例如"3DECBC"、"SHA-1"、"HMAC-SHA1"和"ZLIB"（双引号不是名称的一部分）。此格式的名称只有在首次注册到IANA时才有效。注册名称不能包含"@"、逗号(",")、空格、控制字符(ASCII代码32或更少)或ASCII编码127(DEL)。名称是区分大小写的，不能超过64个字符。
    * 任何人都可以使用格式name@domainname（例如，“ourcipher-cbc@example.com”）来定义其他算法或方法。不具体指定在"@"前面部分的格式；但是，这些名称必须是可打印的US-ASCII字符串，并且不能包含逗号字符（“,”）、空格、控制字符（ASCII编码32或更小）或ASCII编码127（DEL）。他们必须只有一个单独的标志。"@"后面的部分必须是一个有效的、完全限定的域名[RFC1034]，由定义该名称的人或组织控制。名称是区分大小写的，不能超过64个字符。它取决于每个域是如何管理它的本地命名空间的。应该注意的是，这些名称类似于STD 11 [RFC0822]电子邮件地址。这完全是巧合，与STD 11 [RFC0822]无关。

7. 报文编号

    SSH报文包在1到255范围内具有报文编号。这些数字被分配如下：

    传输层协议：

        1 to 19    传输层通用 (例如disconnect, ignore, debug等.)
        20 to 29   算法协商
        30 to 49   密钥交换方法专用 (数字可用于不同的身份验证方法)
    
    用户认证协议：
        
        50 to 59   用户认证通用
        60 to 79   用户身份认证方法（可用于不同身份认证方法）

    连接协议：

        80 to 89   连接协议通用
        90 to 127  channel相关报文

    为客户端协议保留：

        128 to 191 保留
    
    本地扩展：

        192 to 255 本地扩展

8. IANA方面的考虑

    此文档是集合的一部分。本文档中定义的SSH协议的IANA指令[SSH-USERAUTH]、[SSH-TRANS]和[SSH-CONNECT]在[SSH-NUMBERS]中详细描述。为了方便起见，以下是简要的概述，但是请注意，[SSH-NUMBERS]包含IANA的实际指令，这些指令可能在将来被取代。

    在SSH协议中分配以下由IETF协商一致的类型名称：
    * Service Names
        *  Authentication Methods
        *  Connection Protocol Channel Names
        *  Connection Protocol Global Request Names
        *  Connection Protocol Channel Request Names
    * Key Exchange Method Names
    * Assigned Algorithm Names
        * Encryption Algorithm Names
        * MAC Algorithm Names
        * Public Key Algorithm Names
        * Compression Algorithm Names

    这些名称必须是可打印的US-ASCII字符串，并且不能包含符号（“@”）、逗号（“,”）、空格、控制字符（ASCII编码32或更小）或ASCII编码127（DEL）。名称是区分大小写的，不能超过64个字符。

    带有符号（“@”）的名称是局部定义的扩展，而不是由IANA控制的。

    上面列出的每一类名称都有一个单独的命名空间。但是，应该避免在多个类别中使用同名，尽量减少混淆。

    在0到191范围内的报文编号（参见第7节）通过IETF协商一致分配，如[RFC2434]中所描述的。在192到255范围（本地扩展）中的报文编号被预留用于私用，也如[RFC2434]中描述的那样。

9. 安全考虑

    为了使整个安全注意事项主体更易于访问，这里收集了传输、身份验证和连接文档的安全注意事项。

    传输协议[SSH-TANT]在不安全的网络上提供机密channel。它执行服务器主机认证、密钥交换、加密和完整性保护。它还派生出可由高级协议使用的唯一会话ID。

    身份验证协议[SSH-USERAUTH]提供了一组机制，可用于向服务器进行客户端用户的身份认证。认证协议中指定的个别机制会使用传输协议提供的会话id，这取决于传输协议的安全性和完整性保证。

    连接协议[SSH-CONNECT]指定一种机制，用于通过机密和认证的传输来复用多个数据流（channels）。它还指定了用于访问交互式shell、用于通过安全传输（包括任意TCP/IP协议）代理转发各种外部协议以及用于访问服务器主机上的安全子系统的channels。

    1. 伪随机数生成

        该协议通过在用于生成会话密钥的哈希中包括随机的会话特定数据来将每个会话密钥绑定到会话。应特别注意确保所有的随机数都具有良好的质量。如果随机的数据（例如，Diffie-Hellman（DH）参数）是伪随机的，那么伪随机数生成器应该机密且安全（即，它的下一个输出即使在知道所有以前的输出时也不容易猜出）而且，需要将适当的熵添加到伪随机数生成器中。[RFC4086]提供了随机数源和熵的建议。实现者应该注意熵的重要性，以及关于正确实现伪随机数生成函数的困难性的友好示警。给定客户端或服务器可用的熵的数量有时可能小于所需。在这种情况下，要么求助于熵不足的伪随机数生成器，要么拒绝运行该协议。后者更可取。

    2. 控制符过滤

        当向用户显示文本（如错误或调试消息）时，客户端软件应该用安全序列替换任何控制字符（除了制表符、回车符和换行），以避免通过发送终端控制字符进行攻击。
    
    3. 传输

        1. 机密性

            这超出了本文的范围，安全shell工作组分析或推荐特定密码不同于行业内已约定俗成的。在撰写本文时，常用的密码包括3DES、ARC4、TWFISH、serpent和blowfish。AES已经被美国联邦信息处理标准发布为[FIPS-197]，密码学界也接受了AES。一如既往，实现者和用户应该检查当前的文献，以确保在产品中使用的密码中没有发现最近的漏洞。实现者还应该检查哪些密码被认为相对强于其他密码，并且应该向使用相对弱的密码的用户推荐使用它们。对于实现来说，当用户主动选择较弱的密码时，礼貌地、不引人注意地通知用户更强的密码是可用的，这被认为是一种好形式。

            为调试提供“none”密码，除此之外不应使用。在[RFC2410]中充分描述了它的密码特性，这将表明它的使用不符合该协议的意图。

            这些和其他密码的优缺点也可以在当前文献中找到。两个可以提供关于这个主题的参考文献是[SCHNEIER]和[KAUFMAN]。这两种描述了某些密码的CBC操作模式和该方案的弱点。本质上，由于分组序列开始的高可预测性，这种模式理论上容易受到选择的密文攻击。然而，这种攻击被认为是困难的，不被认为是完全可行的，特别是如果使用相对长的块大小。此外，可以通过插入包含SSH_MSG_IGNORE的报文来减轻另一个CBC模式攻击。没有这种技术，特定的攻击可能会成功的。为了使这种攻击（通常称为Rogaway攻击[ROGAWAY]、[DAI]、[BELLARE]）工作，攻击者将需要知道将要加密的下一个块的初始化向量（IV）。在CBC模式中，它是前一个块的加密输出。如果攻击者找不到任何方式来查看数据包（即，它在SSH实现的内部缓冲区中，甚至在内核中），则此攻击将不起作用。如果最后一个包已经被发送到网络（即攻击者可以访问它），那么他可以使用攻击。

            在最佳情况下，只有当数据包已经发送到网络上并且没有其他报文等待传输时，实现者才需要添加额外的数据包。实现者可能希望检查是否有任何未发送的数据包等待传输；不幸的是，通常很难从内核或缓冲区获得此信息。如果没有未发送的数据包，则应该发送包含SSH_MSG_IGNORE的数据包。如果每次攻击者知道下一个数据包应该使用的IV时，都会向流中添加新的数据包，那么攻击者将无法猜测正确的IV，因此攻击将永远不会成功。

            作为一个例子，考虑以下情况：

                Client                                                  Server
                ------                                                  ------
                TCP(seq=x, len=500)             ---->
                contains Record 1

                                    [500 ms passes, no ACK]

                TCP(seq=x, len=1000)            ---->
                contains Records 1,2

                                                                            ACK
            1. Nagle算法 + TCP重传意味着两个记录合并成一个TCP段。
            2. 记录2不是在TCP段的开始，并且永远不会因为它被攻击。
            3. 然而，攻击是可能的，因为已经记录了1。

            如该示例所示，使用TCP缓冲区中未刷新数据的存在作为是否需要空报文的指南是不安全的，因为当执行第二个write()时，缓冲区将包含未ACKed的记录1。

            另一方面，有以下情况是完全安全的：

                Client                                                  Server
                ------                                                  ------
                TCP(seq=x, len=500)             ---->
                    contains SSH_MSG_IGNORE

                TCP(seq=y, len=500)             ---->
                    contains Data
            
            假设在确定了数据包的数据之后，第二个SSH记录的IV被固定，则应该执行以下步骤：

                read from user
                encrypt null packet
                encrypt data packet

        2. 数据完整性

            该协议允许数据完整性机制被禁用。实现者应该谨慎地将此特性暴露于除调试之外的任何目的。在“none” MAC启用时，应明确警告用户和管理员。

            只要没有使用“none” MAC，这个协议就提供了数据完整性。

            因为MACS使用32位序列号，所以在发送了2×32个数据包之后，它们可能开始泄漏信息。然而，按照密钥更新建议应该防止这种攻击。传输协议[SSH-TANT]推荐在一千兆字节的数据之后进行密钥更新，最小可能的数据包是16字节。因此，密钥更新最多应该发生在2×28个数据包之后。
        
        3. 重放

            除了“none”之外，MAC的使用提供了完整性和认证。此外，传输协议提供唯一的会话标识符(部分地绑定到伪随机数据，伪随机数据是算法和密钥交换过程的一部分)，高级协议可以使用该标识符将数据绑定到给定会话，并防止重放来自先前会话的数据。例如，认证协议（[SSH-USERAUTH]）使用它来防止先前会话的签名重放。因为公钥认证交换被加密绑定到会话（即，初始密钥交换），所以它们不能在其他会话中成功地重放。注意，会话ID在不损害协议的安全性时可以公开。

            如果两个会话具有相同的会话ID（密钥交换的哈希），那么其中一个会话的报文可能在另一个会话中重放。必须强调的是，在使用现代加密方法时，这样的发生的可能性当然是极小的。当指定较大的哈希函数输出和DH参数时，这更为真实。

            使用单调递增序列号作为MAC或HMAC在某些情况下的输入的重放检测在[RFC2086]、[RFC2246]、[RFC244]、[RFC1964]、[RFC2025]和[RFC4120 ]中有描述。基础构造在[RFC2104]中讨论。基本上，每个报文中的不同序列号确保至少到MAC函数的这一个输入将是唯一的，并且将提供对攻击者不可预测的非重复MAC输出。但是，如果会话保持足够长的活跃度，这个序列号将被打包。此事件可能给攻击者提供使用相同序列号重放先前记录的报文的机会，但仅限于对等方（peers）自从使用该序列号传输第一个报文以来没有更新密钥的时间段内。如果对等方已更新密钥，若MAC检查失败，将检测重放。出于这个原因，必须强调的是，对等方必须在序列号包装之前更新密钥。当然，如果攻击者确实试图在对等方更新密钥之前重放捕获的报文，那么重复报文的接收方将无法验证MAC，并且将丢弃它。MAC失败的原因是因为接收方将基于报文内容、共享秘密和预期序列号制定MAC。由于重放的报文不会使用预期的序列号（重放报文的序列号已经被接收方通过），所计算的MAC将匹配不上用该报文接收的MAC。

        4. 中间方

            该协议没有假设或规定用于分发主机的公钥的基础设施或手段。预期有时在没有首先验证服务器主机密钥和服务器主机名之间的关联的情况下使用此协议。这种用法易受中间方攻击。本节对此进行描述，并鼓励管理员和用户理解在启动任何会话之前验证此关联的重要性。

            有三个中间方攻击的案例要考虑。首先是攻击者在启动会话之前将设备放置在客户端和服务器之间。在这种情况下，攻击设备试图模仿合法的服务器，并在客户端发起会话时将其公钥提供给客户端。如果它要提供服务器的公钥，那么它将不能解密或签署服务器和客户机之间的合法传输，除非它也能够访问主机的私钥。攻击设备也将同时对此发起到合法服务器的会话，伪装成客户端。如果在会话发起之前服务器的公钥已经安全地分发给客户端，则攻击设备提供给客户端的密钥将不匹配存储在客户端的密钥。在这种情况下，应该给用户一个警告，即所提供的主机密钥与客户端上缓存的主机密钥不匹配。如第4.1节所述，用户可以自由接受新密钥并继续会话。建议警告向客户端设备的用户提供足够的信息，以便用户可以作出知情的决定。如果用户选择使用服务器存储的公钥（而不是会话开始时提供的公钥）继续会话，那么攻击者和服务器之间的会话特定数据在客户端到攻击者会话和攻击者到服务器会话之间将是不同的，由于以上讨论的随机性。由此，攻击者将无法使此攻击起作用，因为攻击者将无法正确地从服务器签名包含此会话特定数据的报文，因为他没有该服务器的私钥。

            应该考虑的第二种情况与第一种情况类似，因为它也发生在连接时，但是这种情况要求需要服务器公钥的安全分发。如果服务器公钥不安全地分发，则客户端无法知道它是否与预期的服务器对话。攻击者可以使用社会工程技术将服务器密钥传递给没有戒心的用户，然后可以将中间人攻击设备放置在合法服务器和客户机之间。如果允许这种情况发生，那么客户端将形成客户端到攻击者会话，并且攻击者将形成攻击者到服务器会话，并且将能够监视和操纵客户端与合法服务器之间的所有通信量。鼓励服务器管理员使用某些安全不依赖于实际主机密钥的完整性的方法来检查主机密钥指纹。可能的机制在第4.1节中讨论，也可以包括安全网页、物理纸张、第4.1节讨论了可能的机制，还可以包括安全网页、物理纸张等。实施者应该提供关于如何最好地实施这些的建议。因为协议是可扩展的，所以协议的未来扩展可以提供更好的机制来处理在连接之前需要知道服务器的主机密钥。例如，通过安全DNS查找使主机密钥指纹可用，或者在密钥交换期间通过GSS-API([RFC1964])使用Kerberos([RFC4120])来验证服务器是可能的。

            在第三个中间方情况下，攻击者可能试图在会话建立之后操纵在对等体（peer）之间传输的报文。正如在第93.3节中所描述的那样，这种性质的成功攻击是非常不可能的。正如第9.3.3节所述，这种推理的确假定MAC是安全的，并且不可能构造MAC算法的输入以给出已知输出。这在[RFC2104]的第6节中有更详细地讨论。如果MAC算法具有漏洞或足够弱，则攻击者可以指定某些输入以产生已知MAC。这样，他们就可以在运输过程中改变一个报文的内容。或者，攻击者可以利用算法漏洞或弱点通过查看来自捕获分组的MAC来发现共享秘密。

            总之，使用此协议而没有主机与其主机密钥之间的绑定的可靠关联是固有的不安全的，并且不推荐。然而，它可能在非安全关键环境中是必需的，并且仍然提供对被动攻击的保护。在这个协议之上运行的协议和应用程序的实现者应该记住这种可能性。

        5. 拒绝服务

            该协议被设计用于可靠的传输。如果发生传输错误或消息操作，则关闭连接。如果发生这种情况，应重新建立连接。这种类型（wire cutter）的拒绝服务攻击几乎是不可能避免的。

            此外，该协议容易受到拒绝服务攻击，因为攻击者可以迫使服务器执行连接设置和密钥交换的CPU和内存密集型任务，而无需进行身份验证。实现者应该提供使此更困难的特性，例如，只允许来自已知具有有效用户的客户端子集的连接。
        
        6. 隐蔽通道

            该协议不是为了消除隐蔽信道而设计的。例如，填充、SSH_MSG_IGNORE消息以及协议中的其他几个位置可以用于传递隐蔽信息，并且接收方没有可靠的方式来验证是否正在发送这样的信息。
        
        7. 前向保密性

            应该注意的是Diffie-Hellman密钥交换可以提供完美的前向保密性（PFS）。PFS本质上被定义为key-establishment协议的密码特性，其中在给定会话之后会话密钥或长期私钥的妥协不会导致任何早期会话[ANSI-T1.523-2001]的妥协。使用密钥交换的SSH会话，使用Soffie-Hellman密钥交换中描述的[SSH-TrANT]（包括Diffie-Hellman -Gulp1-SH1）和“Diffie-Hellman -GROP14-SAH1”的密钥交换是安全的，即使私钥密钥/认证材料稍后被揭示，但是如果会话密钥被显示，则不可用。因此，给定PFS的定义，SSH确实具有PFS。但是，在使用SSH作为传输的任何应用程序或协议中，此属性不会被减少。SSH的传输层为口令认证和依赖于秘密数据的其他方法提供机密性。

            当然，如果显示客户端和服务器的DH私有参数，则会显示会话密钥，但是可以在密钥交换完成之后丢弃这些项。值得指出的是，不应该允许这些项在交换空间中结束，并且它们应该在密钥交换完成后立即从内存中删除。
        
        8. 密钥交换方法的排序

            正如[SSH-TRANS]的算法协商部分所述，每个设备将发送用于密钥交换的优选方法的列表。最优选的方法是列表中的第一个。建议算法通过密码强度排序，最先最强。在[RFC336]中给出了一些额外的指导。
        
        9. 流量分析

            对任何协议的被动监视可能向攻击者提供一些关于会话、用户或协议特定信息的信息，否则攻击者将无法获得这些信息。例如，已经表明，SSH会话的流量分析可以产生关于口令的长度的信息。[Openwall]和[USENIX]实现者应该使用SSH_MSG_IGNORE分组，以及包括随机长度的填充，以阻止流量分析的尝试。也可以找到并实现其他方法。

    4. 认证协议

        该协议的目的是执行客户端用户身份验证。它假定这通过安全传输层协议运行，该协议已经对服务器机器进行了身份验证，建立了加密的通信信道，并为该会话计算唯一的会话标识符。
